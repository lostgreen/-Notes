# 分布式事务提交算法

## 两阶段提交

### 思路描述

两阶段提交算法的目的是解决分布式数据库的并发异常，保证提交阶段的原子性操作。它将事务的提交过程分为两个阶段：
![2PC](image-1.png)

- 准备阶段：协调者节点在本地记录Begin Commit信息到REDO日志;接着协调者向所有参与者询问是否可以执行提交操作，并等待所有参与者答复；收到消息的各参与者检查本地子事务是否可以提交，或者执行子事务操作直到提交前那一刻，将 undo 和 redo 信息记入子事务日志中，但不提交事务。如参与者认为可以提交，将Ready写入本地REDO日志并回应协调者Vote Commit消息，进入就绪状态等待协调者进一步消息；如果参与者本地失败，则返回Vote Abort消息，并写入Abort到本地日志。
- 提交阶段：
  - 若收到所有参与者的Vote Commit：协调者在本地记录Commit信息到REDO日志；接着协调者向所有参与者节点发出Global Commit消息，进入Commit状态；参与者收到Global Commit消息后，记录Commit消息到REDO日志，正式完成提交操作（设置了事务提交完成标志），释放事务期间占用的资源；随后参与者向协调者发送Commit End消息；如果协调者收到了所有参与者的的Commit End消息，在本地记录End Commit信息到REDO日志，完成事务。
  - 若收到某个参与者的Vote Abort，或者协调者在第一阶段的询问超时之前无法获取某些参与者的回应，协调者在本地记录Abort信息到REDO日志；随后协调者向所有参与者节点发出Global Abort消息，进入Abort状态；参与者收到Global Abort消息后，记录Abort消息到REDO日志，利用事务回滚机制执行回滚操作，释放事务期间占用的资源；然后参与者向协调者发送Abort End消息；等待协调者收到了所有参与者的Abort End消息后，事务完成，在本地记录End Abort信息到RED

### 缺点

![drawback](image.png)

- **同步阻塞**：参与者在等待其他参与者节点的响应过程中，所有的参与者节点都是事务阻塞的；
- **单点故障**：协调者一旦发生故障，参与者会一直阻塞下去，尤其在提交阶段，参与者都处于锁定事务资源的状态中；
- **数据不一致**：第二阶段，当协调者向参与者发送commit请求后，发生了局部网络异常或在发送commit请求时协调者发生了故障，若只有部分参与者收到了commit请求，但其他部分未接到commit请求的节点不会执行提交操作，此时出现了数据不一致现象。
- **事务状态丢失**：协调者发出commit消息后宕机，而接收到该消息的参与者也同时宕机，此时无法知道事务的真实状态。

### 改进策略

1. **三阶段提交（3PC）**：3PC是2PC的改进版，通过在第一阶段引入额外的准备阶段来解决某些情况下的阻塞问题，并引入超时机制，允许在发生单点故障时继续达成一致。

2. **基于消息的事务**：使用消息队列等消息传递机制来实现事务的一致性，事务的各个参与者将事务信息发送到消息队列中，协调者根据消息的发送情况来决定事务是否提交或者回滚。

3. **柔性事务**：柔性事务主要特点是保证“基本可用，最终一致”，它允许系统在面对故障时有更多的灵活性，而不是简单地回滚事务。

4. **Paxos协议和Raft算法**：这些协议都是针对分布式系统中事务一致性的改进和优化，提供了不同于2PC的一致性保证。

## 三阶段提交

### 核心思想

三阶段中的 Three Phase 分别为 CanCommit、PreCommit、DoCommit 阶段。
![3PC](image-2.png)

**CanCommit** 阶段
3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 Can-Commit 请求，参与者如果可以提交就返回 Vote Commit 响应，否则返回 Vote Abort 响应。

**PreCommit** 阶段
协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能。
A. 假如协调者从所有的参与者获得的反馈都是 Vote Commit 响应，那么就会进行事务的预执行：

- 发送预提交请求，协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段；
- 事务预提交，参与者接收到 PreCommit 请求后，会执行事务操作；
- 响应反馈，如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。

B. 假如有任何一个参与者向协调者发送了 Vote Abort 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就中断事务：

- 发送中断请求，协调者向所有参与者发送 abort 请求；
- 中断事务，参与者收到来自协调者的 abort 请求之后，执行事务的中断。

**DoCommit** 阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。

A. 执行提交

- 发送提交请求。协调者接收到参与者发送的 ACK 响应后，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。
- 事务提交。参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。
- 响应反馈。事务提交完之后，向协调者发送 ACK 响应。
完成事务。协调者接收到所有参与者的 ACK 响应之后，完成事务。

B. 中断事务 协调者没有接收到参与者发送的 ACK 响应，可能是因为接受者发送的不是 ACK 响应，也有可能响应超时了，那么就会执行中断事务。

C.超时提交 参与者如果没有收到协调者的通知，超时之后会执行 Commit 操作

### 比2PC的优势

- 扩展了超时机制：在 2PC 中，只有协调者拥有超时机制，如果在一定时间内没有收到参与者的消息则默认失败，3PC 同时在协调者和参与者中都引入超时机制。在等待阶段超时后协调者或参与者会中断事务，相对于二阶段提交减小了阻塞范围。
- 避免了协调者单点问题：阶段 3 中，协调者出现问题时，参与者会继续提交事务。

### 劣势

- 缺少分区故障恢复，可用性不高，不能在发生分区故障时进行故障恢复，paxos算法解决了分区故障时的高可用问题；
- 耗时长，至少需要三次网络交互；
- 数据不一致，进入preCommit后，协调者特殊情况下还是可能发出abort请求，此时若只有一个参与者收到并回滚，其他对于系统状态未知的参与者会依据3PC选择继续Commit，此时系统状态出现不一致。

## 基于Paxos的提交
